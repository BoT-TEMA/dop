# **1) Проверка скобочной последовательности**

**Исходный код**: [Искать здесь](/brackets.cpp)  

## **1. Цель работы**
Реализовать программу на C++, которая проверяет корректность расстановки скобок в строке (включая `()`, `[]`, `{}`) с использованием стека.

## **2. Используемые структуры данных и алгоритмы**
### **2.1. Структура данных: стек (`std::stack`)**
- **Назначение**:  
  Стек используется для отслеживания порядка открывающих скобок. Принцип LIFO (Last In, First Out) позволяет корректно проверять вложенность скобок.
- **Операции**:
  - `push()` — добавление скобки в стек.
  - `pop()` — удаление верхнего элемента.
  - `top()` — получение верхнего элемента без удаления.
  - `empty()` — проверка на пустоту.

### **2.2. Алгоритм проверки**
1. **Инициализация**:
   - Создается стек для хранения открывающих скобок.
   - Используется словарь (`unordered_map`) для сопоставления закрывающих скобок с открывающими:
     ```cpp
     { ')': '(', ']': '[', '}': '{' }
     ```
2. **Пошаговая проверка**:
   - Если встречается **открывающая скобка** → кладем в стек.
   - Если встречается **закрывающая скобка** → проверяем соответствие с вершиной стека.
     - Если стек пуст или скобки не совпадают → последовательность **неправильная**.
     - Иначе удаляем скобку из стека (`pop()`).
3. **Финал**:
   - Если после обработки строки стек пуст → последовательность **правильная**.
   - Иначе — **неправильная** (не все скобки закрыты).

## **3. Реализация программы**
### **3.1. `bool isBalanced(const string &s)`**  
   Проверяет баланс скобок в строке `s`:
   ```cpp
   bool Balance(const string &s) {
    stack<char> brackets;
    unordered_map<char, char> map_brackets = {
        {')', '('},
        {']', '['},
        {'}', '{'}
    };

    for (char c : s) {
        if (c == '(' || c == '[' || c == '{') {
            brackets.push(c);
        } else if (c == ')' || c == ']' || c == '}') {
            if (brackets.empty() || brackets.top() != map_brackets[c]) {
                return false;
            }
            brackets.pop();
        }
    }

    return brackets.empty();
}
   ```


### **3.2. Примеры работы**
| Ввод          | Результат       | Объяснение                     |
|---------------|----------------|--------------------------------|
| `([]{})`      | ✅ Правильно    | Корректная вложенность         |
| `({[}])`      | ❌ Неправильно | `{` закрывается `]` — ошибка   |
| `((())`       | ❌ Неправильно | Не хватает закрывающей `)`     |



# **2) Минимум в окне**  

**Исходный код**: [Искать здесь](/min_wind.cpp)  

## **1. Цель работы**  
Программа предназначена для нахождения минимальных значений в каждом скользящем окне фиксированного размера `K` для заданной последовательности чисел длиной `N`.  

## **2. Используемый алгоритм**  
Алгоритм основан на использовании **дека(deque) (двусторонней очереди)** для эффективного отслеживания кандидатов в минимумы.  

### **Принцип работы:**  
1. **Дек хранит индексы элементов** в порядке возрастания значений.  
2. При добавлении нового элемента:  
   - Удаляются все элементы из **конца дека**, которые **больше или равны** текущему, так как они больше не могут быть минимумами.  
   - Новый элемент добавляется в конец.  
3. При сдвиге окна:  
   - Удаляются индексы из **начала дека**, если они вышли за границы текущего окна.  
4. Минимум текущего окна — это элемент в **начале дека**.  

### **Преимущества:**  
- Время работы: **O(N)** (каждый элемент обрабатывается ровно один раз).  
- Память: **O(K)** (в худшем случае дек хранит `K` элементов).  


## **3. Тестирование**  
### **Пример 1:**  
**Вход:**  
```
N = 8, K = 3  
Последовательность: [1, 3, -1, -3, 5, 3, 6, 7]  
```  
**Выход:**  
```
Минимумы в окнах: -1 -3 -3 -3 3 3  
```  
**Объяснение:**  
- Окно `[1, 3, -1]` → минимум `-1`  
- Окно `[3, -1, -3]` → минимум `-3`  
- Окно `[-1, -3, 5]` → минимум `-3`  
- Окно `[-3, 5, 3]` → минимум `-3`  
- Окно `[5, 3, 6]` → минимум `3`  
- Окно `[3, 6, 7]` → минимум `3`  

### **Пример 2:**  
**Вход:**  
```
N = 5, K = 2  
Последовательность: [4, 2, 1, 5, 3]  
```  
**Выход:**  
```
Минимумы в окнах: 2 1 1 3  
```  

